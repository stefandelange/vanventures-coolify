#!/usr/bin/env node

import { promises as fs } from "node:fs";
import path from "node:path";
import matter from "gray-matter";

const ROOT_DIR = process.cwd();
const CONTENT_ROOT_DIR = path.join(ROOT_DIR, "content");
const OUTPUT_DIR = path.join(ROOT_DIR, "src", "generated");
const OUTPUT_FILE = path.join(OUTPUT_DIR, "posts-source.ts");

async function ensureOutputDir() {
  await fs.mkdir(OUTPUT_DIR, { recursive: true });
}

async function loadMarkdownFiles() {
  const records = [];

  async function walk(currentDir, segments = []) {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });
    const sorted = entries.sort((a, b) => a.name.localeCompare(b.name));

    for (const entry of sorted) {
      if (entry.isDirectory()) {
        await walk(path.join(currentDir, entry.name), [...segments, entry.name]);
        continue;
      }

      // Check for locale-specific markdown files (.en.md, .de.md)
      const localeMatch = entry.name.match(/\.(en|de)\.md$/);
      if (!entry.isFile() || !localeMatch) {
        continue;
      }

      const locale = localeMatch[1]; // 'en' or 'de'
      const filePath = path.join(currentDir, entry.name);
      const fileContents = await fs.readFile(filePath, "utf8");
      const parsed = matter(fileContents);
      const slug = entry.name.replace(/\.(en|de)\.md$/, "");

      records.push({
        slug,
        locale,
        data: parsed.data ?? {},
        content: parsed.content ?? "",
        collectionSegments: segments,
        relativePath: path.relative(CONTENT_ROOT_DIR, filePath),
      });
    }
  }

  await walk(CONTENT_ROOT_DIR);
  return records;
}

function createFileContents(records) {
  const banner =
    "// This file is auto-generated by scripts/generate-posts.mjs. Do not edit manually.\n";
  const typeDef =
    "export type PostSourceRecord = {\n" +
    "  slug: string;\n" +
    "  locale: string;\n" +
    "  data: Record<string, unknown>;\n" +
    "  content: string;\n" +
    "  collectionSegments: string[];\n" +
    "  relativePath: string;\n" +
    "};\n\n";

  const json = JSON.stringify(records, null, 2);
  const exportStatement = `export const postsSource = ${json} satisfies PostSourceRecord[];\n`;

  return `${banner}\n${typeDef}${exportStatement}`;
}

async function main() {
  await ensureOutputDir();
  const records = await loadMarkdownFiles();
  const fileContents = createFileContents(records);
  await fs.writeFile(OUTPUT_FILE, fileContents, "utf8");
  console.log(`Generated ${path.relative(ROOT_DIR, OUTPUT_FILE)}`);
}

main().catch((error) => {
  console.error("Failed to generate posts source:", error);
  process.exitCode = 1;
});
